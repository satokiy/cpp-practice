# 関数ポインタ

## プログラムの進み方

- C言語で書いたプログラムは、ビルドすると機械語に変換される
  - 機械語はただの数字の羅列

## 簡易イメージ

```c:samle.c
char a = 5;
char b = 7 + 6;
```

↓↓ 変換

```c:samle.c
01, a0, 05, 02, a1, 07, 06
// 適当だけど、こんなイメージ
```

↓↓ 変換したものをRAM上に配置

|       |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  00   |       |       |  01   |  a0   |  05   |  02   |  a1   |  07   |  06   |       |
|  10   |       |       |       |       |       |       |       |       |       |       |
|  20   |       |       |       |       |       |       |       |       |       |       |

- まず`char a = 5`を解釈する
- プログラムカウンタが2番地を指すところから始まる
- 変換された機械語の羅列は、命令→情報という順序で並んでいる
  - 01: 代入命令
  - a0: 代入先のアドレス
  - 05: 代入する値
    - ここまで実行が終わったら、プログラムカウンタを3つ進める
    - プログラムカウンタは5番地を指す
  - 02: 足し算
  - a1: 代入先のアドレス
  - 07: 足す値
  - 06: 足す値
    - ここまで実行が終わったら、プログラムカウンタを4つ進める
    - プログラムカウンタは9番地を指す
    - 最後まで行ったのでプログラムは終了

## 関数を使う場合

```c:samle.c
void func() {
    char a = 5; // 01, a0, 05
    char b = 7 + 6; // 02, a1, 07, 06
} // 03: func()の終了時のreturn


void main() { // 04, 0a
    func(); // 04, 02
}
```

↓↓ 変換

```c:samle.c
04, 0a, 01, a0, 05, 02, a1, 07, 06, 03, 04, 02

```

↓↓ 変換したものをRAM上に配置

|       |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  00   |       |       |  04   |  0a   |  01   |  a0   |  05   |  02   |  a1   |  07   |
|  10   |  06   |  03   |  04   |  02   |       |       |       |       |       |       |
|  20   |       |       |       |       |       |       |       |       |       |       |

- 機械語の実行
  - 04: jump命令
    - 関数の呼び出し = 指定のアドレスまでプログラムカウンタを移動させること
  - 0a: jump先のアドレス
    - 0a番地(10番地の04)に飛ぶ
  - 04: jump命令
  - 02: jump先のアドレス
    - 02番地(02番地の01)に飛ぶ
  - 01: 代入命令
  - ~以下中略~
  - 06: 代入する値
  - 03: return命令
    - 関数の終了 = 呼び出し元に戻ること
    - 0a番地の命令実行後の12番地に戻る
    - 終了

### 関数のアドレスとは

- 関数を呼び出す際の先頭アドレス
- 上記のケースでは、main関数を呼び出す際の先頭アドレスは0a番地。func関数を呼び出す際の先頭アドレスは02番地


## 関数ポインタとは

- 関数のアドレスを保存するための変数
  - 上記の例では、main関数のアドレスは`0a`、func関数のアドレスは`02`

```c:samle.c
void func() {
    char a = 5;
    char b = 7 + 6;
}

int func2(int a, int b) {
    return a + b;
}

int main() {
    // 関数ポインタの宣言
    void (*ptr)();
    ptr = func;
    ptr();

    // 関数ポインタの宣言と初期化
    int (*ptr2)(int, int) = func2;
    int val = ptr2(1, 2);
}
```

- 関数ポインタの呼び出しによって関数が実行できる
  - `ptr()`は`func()`と同じ
  - `ptr2(1, 2)`は`func2(1, 2)`と同じ

### typedefを利用した書き方

```c:samle.c
typedef void (*MYPROC)(); // procedureとは戻り地のない関数のこと

typedef struct tagCharactor {
    char name[32];
    int life;
    MYPROC action;
} CHARACTOR;

void Attack() {
    printf("攻撃\n");
}

void Magic() {
    printf("魔法\n");
}

CHARACTOR players[] = {
    {"勇者", 100, Attack},
    {"魔法使い", 50, Magic}
};
int main() {
    players[0].action(); // "攻撃"と表示される
    players[1].action(); // "魔法"と表示される

}
```